<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First-Person Multiplayer Game</title>
    <link rel="stylesheet" href="style.css">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <!-- Three.js and related libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/pmrem/PMREMGenerator.js"></script>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>First-Person Multiplayer Game</h1>
            <p>Click to play</p>
            <p>W, A, S, D = Move, Mouse = Look around</p>
            <p id="player-id">Connecting...</p>
        </div>
    </div>
    <div id="container"></div>

    <!-- Game scripts -->
    <script src="controls.js"></script>
    <script>
        // Initialize Firebase
        // IMPORTANT: Replace with your Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyCZrLCnjCyUvMOzDe-yeB185qrN8M97LP4",
            authDomain: "github-1ec60.firebaseapp.com",
            databaseURL: "https://github-1ec60-default-rtdb.firebaseio.com",
            projectId: "github-1ec60",
            storageBucket: "github-1ec60.firebasestorage.app",
            messagingSenderId: "370562737308",
            appId: "G-JDV0KHPD7F"
        };
        
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        // Generate a random player ID
        const playerId = 'player_' + Math.random().toString(36).substr(2, 9);
        document.getElementById('player-id').textContent = 'Your ID: ' + playerId;
        
        // Reference to store player positions
        const playersRef = database.ref('players');
        
        // Store other player objects
        const otherPlayers = {};
        
        // Wait for the DOM to load
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.getElementById('container');
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            
            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue background
            
            // Advanced renderer setup with shadows
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);
            
            // Camera setup for first-person view
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 0); // Eye height
            
            // Pointer lock controls for first-person view
            const controls = new THREE.PointerLockControls(camera, document.body);
            
            // Click to start
            instructions.addEventListener('click', function() {
                controls.lock();
            });
            
            controls.addEventListener('lock', function() {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            
            controls.addEventListener('unlock', function() {
                blocker.style.display = 'block';
                instructions.style.display = '';
            });
            
            scene.add(controls.getObject());
            
            // Advanced lighting setup
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffaa, 1.0);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Additional hemisphere light for realistic ambient lighting
            const hemiLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
            scene.add(hemiLight);
            
            // Environment map for reflections
            const rgbeLoader = new THREE.RGBELoader();
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            
            let envMap;
            
            // Load HDR environment map for realistic reflections
            rgbeLoader.setDataType(THREE.UnsignedByteType)
                .load('https://threejs.org/examples/textures/equirectangular/venice_sunset_1k.hdr', function(texture) {
                    envMap = pmremGenerator.fromEquirectangular(texture).texture;
                    scene.environment = envMap;
                    
                    texture.dispose();
                    pmremGenerator.dispose();
                    
                    // Create materials after environment map is loaded
                    setupMaterials();
                });
            
            // Materials for various objects
            let groundMaterial, wallMaterial;
            
            function setupMaterials() {
                // Ground material with reflection
                groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x556b2f,
                    roughness: 0.7,
                    metalness: 0.1,
                    envMap: envMap,
                    side: THREE.DoubleSide
                });
                
                // Create ground
                const groundGeometry = new THREE.PlaneGeometry(40, 40, 32, 32);
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
                
                // Wall material with normal mapping for detail
                wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x808080,
                    roughness: 0.6,
                    metalness: 0.2,
                    envMap: envMap
                });
                
                // Load texture for walls
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    'wall.png',
                    (texture) => {
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(2, 1);
                        wallMaterial.map = texture;
                        
                        // Also load a normal map for better detail
                        textureLoader.load(
                            'wall_normal.png', 
                            (normalMap) => {
                                wallMaterial.normalMap = normalMap;
                                wallMaterial.normalScale.set(1, 1);
                                wallMaterial.needsUpdate = true;
                            },
                            undefined,
                            (err) => console.log("Normal map not found, using without it")
                        );
                        
                        wallMaterial.needsUpdate = true;
                        createWalls();
                    },
                    undefined,
                    (err) => {
                        console.log("Couldn't load texture, creating walls with default material");
                        createWalls();
                    }
                );
            }
            
            // Wall creation function
            function createWalls() {
                createWall(0, -20);
                createWall(0, 20);
                createWall(-20, 0, Math.PI / 2);
                createWall(20, 0, Math.PI / 2);
            }
            
            function createWall(x, z, rotateY = 0) {
                const wallGeometry = new THREE.BoxGeometry(40, 5, 0.5);
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x, 2.5, z);
                wall.rotation.y = rotateY;
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                return wall;
            }
            
            // Player object for first person (invisible in first-person mode)
            let player = new THREE.Object3D();
            scene.add(player);
            let playerLoaded = true; // We don't need to wait for model loading in first-person
            
            // Player model for other players to see
            let playerModel;
            
            // Load player model for other players
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load(
                'models/character_sktail2a.glb',
                (gltf) => {
                    playerModel = gltf.scene;
                    
                    // Scale and prepare the model
                    playerModel.scale.set(0.5, 0.5, 0.5);
                    
                    // Apply realistic materials to the model
                    playerModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Enhance material properties for better rendering
                            if (child.material) {
                                child.material.envMap = envMap;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    // Refresh existing other players with the new model
                    for (const id in otherPlayers) {
                        updateOtherPlayerModel(id);
                    }
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    console.error('Error loading model:', error);
                    // We'll use a fallback model for other players
                }
            );
            
            // Movement variables
            const moveForward = moveBackward = moveLeft = moveRight = false;
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            
            // Set up controls from the imported controls.js
            setupControls(controls, moveForward, moveBackward, moveLeft, moveRight);
            
            // Update player position in Firebase (throttled)
            let lastUpdate = 0;
            function updatePlayerPositionInFirebase() {
                const now = Date.now();
                // Update at most every 50ms for smoother remote player movements
                if (now - lastUpdate > 50) {
                    lastUpdate = now;
                    
                    const position = controls.getObject().position;
                    const rotation = new THREE.Euler().setFromQuaternion(camera.quaternion);
                    
                    playersRef.child(playerId).set({
                        position: {
                            x: position.x,
                            y: position.y,
                            z: position.z
                        },
                        rotation: {
                            y: rotation.y
                        },
                        lastUpdated: firebase.database.ServerValue.TIMESTAMP
                    });
                }
            }
            
            // Function to update the model used by other players
            function updateOtherPlayerModel(id) {
                if (!otherPlayers[id] || !playerModel) return;
                
                // Remove old mesh
                while(otherPlayers[id].children.length > 0) {
                    otherPlayers[id].remove(otherPlayers[id].children[0]);
                }
                
                // Add new model as a child
                const newModel = playerModel.clone();
                otherPlayers[id].add(newModel);
            }
            
            // Handle other players
            function createOrUpdateOtherPlayer(id, data) {
                if (id === playerId) return; // Skip self
                
                if (!otherPlayers[id]) {
                    // Create a new object for this player
                    const otherPlayer = new THREE.Object3D();
                    scene.add(otherPlayer);
                    otherPlayers[id] = otherPlayer;
                    
                    // If we have the player model loaded, use it
                    if (playerModel) {
                        const newModel = playerModel.clone();
                        otherPlayer.add(newModel);
                    } else {
                        // Fallback to a colored capsule until model loads
                        const capsuleGeom = new THREE.CapsuleGeometry(0.3, 1.0, 4, 8);
                        const capsuleMat = new THREE.MeshStandardMaterial({ 
                            color: 0x0088ff,
                            roughness: 0.7,
                            metalness: 0.3
                        });
                        const capsule = new THREE.Mesh(capsuleGeom, capsuleMat);
                        capsule.castShadow = true;
                        capsule.position.y = 0.85; // Center the capsule
                        otherPlayer.add(capsule);
                    }
                }
                
                // Get the current position/rotation
                const otherPlayer = otherPlayers[id];
                const currentPos = otherPlayer.position.clone();
                const targetPos = new THREE.Vector3(
                    data.position.x,
                    data.position.y,
                    data.position.z
                );
                
                // Store target position for interpolation
                otherPlayer.userData.targetPosition = targetPos;
                otherPlayer.userData.startPosition = currentPos;
                otherPlayer.userData.interpolationStart = Date.now();
                
                // Also store rotation
                if (data.rotation) {
                    otherPlayer.userData.targetRotation = data.rotation.y;
                }
            }
            
            // Listen for other players' updates
            playersRef.on('value', (snapshot) => {
                const players = snapshot.val() || {};
                
                // Add or update other players
                for (const id in players) {
                    if (id !== playerId) {
                        createOrUpdateOtherPlayer(id, players[id]);
                    }
                }
                
                // Remove disconnected players
                for (const id in otherPlayers) {
                    if (!players[id]) {
                        scene.remove(otherPlayers[id]);
                        delete otherPlayers[id];
                    }
                }
            });
            
            // Clean up player data when they disconnect
            window.addEventListener('beforeunload', () => {
                playersRef.child(playerId).remove();
            });
            
            // Automatically remove inactive players
            function cleanupInactivePlayers() {
                const now = Date.now();
                const timeoutDuration = 10000; // 10 seconds
                
                playersRef.once('value', (snapshot) => {
                    const players = snapshot.val() || {};
                    
                    for (const id in players) {
                        const player = players[id];
                        if (player.lastUpdated && now - player.lastUpdated > timeoutDuration) {
                            playersRef.child(id).remove();
                        }
                    }
                });
            }
            
            // Clean up inactive players every 30 seconds
            setInterval(cleanupInactivePlayers, 30000);
            
            // Clock for animation and physics
            const clock = new THREE.Clock();
            
            // Animation loop
            const animate = () => {
                requestAnimationFrame(animate);
                
                const delta = clock.getDelta();
                
                if (controls.isLocked) {
                    // Process movement using WASD
                    // This logic moved to controls.js
                    processMovement(delta, velocity, direction, controls, 
                                  moveForward, moveBackward, moveLeft, moveRight);
                    
                    // Simple collision detection with boundaries
                    const playerPos = controls.getObject().position;
                    if (playerPos.x > 19.5) playerPos.x = 19.5;
                    if (playerPos.x < -19.5) playerPos.x = -19.5;
                    if (playerPos.z > 19.5) playerPos.z = 19.5;
                    if (playerPos.z < -19.5) playerPos.z = -19.5;
                    
                    // Keep y position stable (no jumping/falling in this version)
                    if (playerPos.y !== 1.7) playerPos.y = 1.7;
                    
                    // Update position in Firebase if player moved
                    updatePlayerPositionInFirebase();
                }
                
                // Smoothly interpolate other players' positions
                for (const id in otherPlayers) {
                    const otherPlayer = otherPlayers[id];
                    
                    if (otherPlayer.userData.targetPosition && otherPlayer.userData.startPosition) {
                        const now = Date.now();
                        const interpolationDuration = 100; // ms, matching our update rate
                        const elapsed = now - otherPlayer.userData.interpolationStart;
                        const progress = Math.min(elapsed / interpolationDuration, 1);
                        
                        // Lerp position for smooth movement
                        otherPlayer.position.lerpVectors(
                            otherPlayer.userData.startPosition,
                            otherPlayer.userData.targetPosition,
                            progress
                        );
                        
                        // Smoothly rotate to target rotation
                        if (otherPlayer.userData.targetRotation !== undefined) {
                            otherPlayer.rotation.y = THREE.MathUtils.lerp(
                                otherPlayer.rotation.y || 0,
                                otherPlayer.userData.targetRotation,
                                progress
                            );
                        }
                    }
                }
                
                renderer.render(scene, camera);
            };
            
            // Start the game
            animate();
            
            // Handle window resize
            function handleResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            window.addEventListener('resize', handleResize);
        });
    </script>
</body>
</html>
