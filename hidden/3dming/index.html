<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' https://cdnjs.cloudflare.com 'unsafe-inline';">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Unity-Style WebGL Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e2430 0%, #0d1117 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
        }
        #progressBar {
            width: 50%;
            height: 20px;
            background-color: #222;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #1abc9c);
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }
        #gameTitle {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.7);
        }
        #menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 17, 25, 0.9);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 20px;
            color: white;
            width: 300px;
            z-index: 5;
        }
        .menuTitle {
            text-align: center;
            font-size: 1.5em;
            margin-bottom: 20px;
            border-bottom: 1px solid #3498db;
            padding-bottom: 10px;
        }
        .menuButton {
            background: linear-gradient(90deg, #3498db, #2980b9);
            border: none;
            color: white;
            padding: 10px;
            width: 100%;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .menuButton:hover {
            background: linear-gradient(90deg, #2980b9, #3498db);
            transform: scale(1.05);
        }
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        .setting {
            margin: 15px 0;
        }
        #playerStats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(10, 17, 25, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
        }
        .healthBar {
            width: 100%;
            height: 10px;
            background-color: #222;
            border-radius: 5px;
            margin-top: 5px;
        }
        .healthFill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            width: 100%;
            border-radius: 5px;
            transition: width 0.5s;
        }
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #3498db;
            border-radius: 50%;
            overflow: hidden;
            display: none;
        }
        #playerList {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 17, 25, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            max-width: 200px;
            display: none;
        }
        .player {
            margin: 5px 0;
            padding: 3px;
            display: flex;
            align-items: center;
        }
        .playerColor {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
        }
        #crosshair:before, #crosshair:after {
            content: "";
            position: absolute;
            background-color: white;
        }
        #crosshair:before {
            top: 9px;
            left: 0;
            width: 20px;
            height: 2px;
        }
        #crosshair:after {
            top: 0;
            left: 9px;
            width: 2px;
            height: 20px;
        }
        #chatBox {
            position: absolute;
            left: 20px;
            bottom: 100px;
            width: 300px;
            background: rgba(10, 17, 25, 0.7);
            border-radius: 5px;
            color: white;
            max-height: 150px;
            overflow-y: auto;
            display: none;
        }
        .chatMessage {
            margin: 5px;
            word-break: break-word;
        }
        #chatInput {
            position: absolute;
            left: 20px;
            bottom: 70px;
            width: 300px;
            display: none;
        }
        #chatInput input {
            width: 100%;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #3498db;
            background: rgba(10, 17, 25, 0.9);
            color: white;
        }
        .notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(52, 152, 219, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 17, 25, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="gameTitle">UNITY WEBGL EXPLORER</div>
        <div>Loading resources...</div>
        <div id="progressBar">
            <div id="progressFill"></div>
        </div>
        <div id="loadingText">Initializing game environment...</div>
    </div>
    
    <div id="menu">
        <div class="menuTitle">Game Menu</div>
        <button class="menuButton" id="resumeButton">Resume Game</button>
        <div class="setting">
            <label for="sensitivitySlider">Mouse Sensitivity</label>
            <input type="range" min="1" max="10" value="5" class="slider" id="sensitivitySlider">
        </div>
        <div class="setting">
            <label for="volumeSlider">Sound Volume</label>
            <input type="range" min="0" max="10" value="7" class="slider" id="volumeSlider">
        </div>
        <div class="setting">
            <label for="graphicsSelect">Graphics Quality</label>
            <select id="graphicsSelect" class="menuButton">
                <option value="low">Low</option>
                <option value="medium" selected>Medium</option>
                <option value="high">High</option>
            </select>
        </div>
        <button class="menuButton" id="respawnButton">Respawn</button>
        <button class="menuButton" id="restartButton">Restart Game</button>
    </div>
    
    <div id="playerStats">
        <div>Health: <span id="healthValue">100</span>/100</div>
        <div class="healthBar">
            <div class="healthFill" id="healthFill"></div>
        </div>
        <div>Score: <span id="scoreValue">0</span></div>
        <div>Current Weapon: <span id="weaponValue">Pistol</span></div>
    </div>
    
    <div id="minimap"></div>
    
    <div id="playerList">
        <div>Online Players (5)</div>
        <div id="playerListContent"></div>
    </div>
    
    <div id="crosshair"></div>
    
    <div id="chatBox"></div>
    <div id="chatInput">
        <input type="text" placeholder="Press Enter to chat..." disabled>
    </div>
    
    <div id="instructions">
        WASD or Arrow Keys: Move<br>
        Mouse: Look around<br>
        Space: Jump<br>
        Click: Shoot<br>
        R: Reload<br>
        1-3: Change weapon<br>
        T: Open chat<br>
        ESC: Menu
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game states
        const GameState = {
            LOADING: 0,
            MENU: 1,
            PLAYING: 2,
            PAUSED: 3
        };
        
        let currentState = GameState.LOADING;
        let menuOpen = false;
        
        // Game configuration
        const config = {
            sensitivity: 0.002,
            volume: 0.7,
            graphics: 'medium'
        };
        
        // Player stats
        const player = {
            health: 100,
            score: 0,
            weapon: 'Pistol',
            height: 1.8,
            speed: 0.15,
            jumpForce: 0.2,
            gravity: 0.007,
            velocity: new THREE.Vector3(0, 0, 0),
            onGround: true,
            canJump: true,
            lastShot: 0,
            shootCooldown: 500, // milliseconds
            ammo: {
                'Pistol': 12,
                'Rifle': 30,
                'Shotgun': 8
            },
            maxAmmo: {
                'Pistol': 12,
                'Rifle': 30,
                'Shotgun': 8
            },
            color: new THREE.Color(0x3498db)
        };
        
        // Controls state
        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            shoot: false,
            reload: false,
            chat: false,
            weapon1: false,
            weapon2: false,
            weapon3: false
        };
        
        // Pointer lock API controls
        const pointerLock = {
            isLocked: false
        };
        
        // Three.js variables
        let scene, camera, renderer, clock;
        let ground, skybox;
        let lights = [];
        let objects = [];
        let botPlayers = [];
        let projectiles = [];
        let minimapScene, minimapCamera, minimapRenderer;
        
        // DOM elements
        const loadingScreen = document.getElementById('loadingScreen');
        const progressFill = document.getElementById('progressFill');
        const loadingText = document.getElementById('loadingText');
        const menuElement = document.getElementById('menu');
        const playerStats = document.getElementById('playerStats');
        const minimap = document.getElementById('minimap');
        const playerList = document.getElementById('playerList');
        const chatBox = document.getElementById('chatBox');
        const chatInput = document.getElementById('chatInput');
        const crosshair = document.getElementById('crosshair');
        const instructions = document.getElementById('instructions');
        
        // Initialize the game
        function init() {
            // Simulate loading process
            simulateLoading();
            
            // Set up Three.js
            setupThreeJS();
            
            // Set up event listeners
            setupEventListeners();
            
            // Create game environment
            createEnvironment();
            
            // Create bot players
            createBotPlayers();
            
            // Set up minimap
            setupMinimap();
            
            // Set up player list
            setupPlayerList();
            
            // Start animation loop
            animate();
        }
        
        function simulateLoading() {
    console.log("Bypassing loading screen...");
    loadingScreen.style.display = 'none'; // Hide the loading screen immediately
    currentState = GameState.PLAYING; // Set the game state to Playing
    showGameElements(); // Show the game elements
}
    
        
        // Set up Three.js environment
        function setupThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            clock = new THREE.Clock();
            
            // Set initial camera position
            camera.position.set(0, player.height, 0);
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (event) => {
                if (currentState === GameState.PLAYING && !menuOpen) {
                    handleKeyDown(event);
                } else if (event.code === 'Escape' && currentState === GameState.PLAYING) {
                    toggleMenu();
                }
            });
            
            document.addEventListener('keyup', (event) => {
                handleKeyUp(event);
            });
            
            // Mouse events
            document.addEventListener('click', (event) => {
                if (currentState === GameState.PLAYING && !menuOpen) {
                    if (!pointerLock.isLocked) {
                        renderer.domElement.requestPointerLock();
                    } else {
                        shoot();
                    }
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                pointerLock.isLocked = document.pointerLockElement === renderer.domElement;
                if (!pointerLock.isLocked && currentState === GameState.PLAYING) {
                    toggleMenu();
                }
            });
            
            document.addEventListener('mousemove', (event) => {
                if (pointerLock.isLocked && currentState === GameState.PLAYING && !menuOpen) {
                    camera.rotation.y -= event.movementX * config.sensitivity;
                    const verticalLook = camera.rotation.x + event.movementY * config.sensitivity;
                    camera.rotation.x = Math.max(Math.min(verticalLook, Math.PI / 2 - 0.1), -Math.PI / 2 + 0.1);
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                if (minimapRenderer) {
                    minimapRenderer.setSize(150, 150);
                }
            });
            
            // Menu buttons
            document.getElementById('resumeButton').addEventListener('click', toggleMenu);
            document.getElementById('respawnButton').addEventListener('click', respawnPlayer);
            document.getElementById('restartButton').addEventListener('click', restartGame);
            
            // Menu sliders
            document.getElementById('sensitivitySlider').addEventListener('input', (e) => {
                config.sensitivity = e.target.value * 0.0005;
            });
            
            document.getElementById('volumeSlider').addEventListener('input', (e) => {
                config.volume = e.target.value / 10;
            });
            
            document.getElementById('graphicsSelect').addEventListener('change', (e) => {
                config.graphics = e.target.value;
                updateGraphicsQuality();
            });
        }
        
        // Handle key down events
        function handleKeyDown(event) {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.forward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.backward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = true;
                    break;
                case 'Space':
                    keys.jump = true;
                    break;
                case 'KeyR':
                    reloadWeapon();
                    break;
                case 'KeyT':
                    toggleChat();
                    break;
                case 'Digit1':
                    changeWeapon('Pistol');
                    break;
                case 'Digit2':
                    changeWeapon('Rifle');
                    break;
                case 'Digit3':
                    changeWeapon('Shotgun');
                    break;
                case 'Escape':
                    toggleMenu();
                    break;
            }
        }
        
        // Handle key up events
        function handleKeyUp(event) {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.forward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.backward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'Space':
                    keys.jump = false;
                    break;
            }
        }
        
        // Create game environment
        function createEnvironment() {
            // Create skybox
            const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyboxMaterials = [
                new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide })
            ];
            skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
            scene.add(skybox);
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x3d9140,
                side: THREE.DoubleSide,
                wireframe: false
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Create some terrain variation
            for (let i = 0; i < 50; i++) {
                const hill = createHill(
                    Math.random() * 180 - 90,
                    Math.random() * 180 - 90,
                    Math.random() * 5 + 3,
                    Math.random() * 10 + 5
                );
                objects.push(hill);
            }
            
            // Create buildings
            for (let i = 0; i < 20; i++) {
                const building = createBuilding(
                    Math.random() * 160 - 80,
                    Math.random() * 160 - 80,
                    Math.random() * 5 + 3,
                    Math.random() * 5 + 3,
                    Math.random() * 8 + 4
                );
                objects.push(building);
            }
            
            // Create trees
            for (let i = 0; i < 30; i++) {
                const tree = createTree(
                    Math.random() * 180 - 90,
                    Math.random() * 180 - 90
                );
                objects.push(tree);
            }
            
            // Create lights
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            lights.push(ambientLight);
            
            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 30);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            lights.push(directionalLight);
        }
        
        // Create a hill
        function createHill(x, z, height, radius) {
            const geometry = new THREE.ConeGeometry(radius, height, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0x3d9140,
                flatShading: true
            });
            const hill = new THREE.Mesh(geometry, material);
            hill.position.set(x, height / 2 - 1, z);
            hill.castShadow = true;
            hill.receiveShadow = true;
            scene.add(hill);
            return hill;
        }
        
        // Create a building
        function createBuilding(x, z, width, depth, height) {
            const group = new THREE.Group();
            
            // Building body
            const bodyGeometry = new THREE.BoxGeometry(width, height, depth);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.5, 0.5),
                flatShading: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = height / 2 - 1;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // Windows
            const windowSize = 0.5;
            const windowGeometry = new THREE.PlaneGeometry(windowSize, windowSize);
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                emissive: 0x88ccff,
                emissiveIntensity: 0.3
            });
            
            // Add windows to the building
            for (let i = 0; i < Math.floor(height); i++) {
                for (let j = 0; j < Math.floor(width); j++) {
                    if (Math.random() > 0.3) {
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            j - width / 2 + 0.5,
                            i + 0.5,
                            depth / 2 + 0.01
                        );
                        windowMesh.rotation.y = Math.PI;
                        group.add(windowMesh);
                        
                        // Back window
                        const backWindow = windowMesh.clone();
                        backWindow.position.z = -depth / 2 - 0.01;
                        backWindow.rotation.y = 0;
                        group.add(backWindow);
                        
                        // Side windows
                        if (j === 0 || j === Math.floor(width) - 1) {
                            const sideWindow = windowMesh.clone();
                            sideWindow.position.x = j === 0 ? -width / 2 - 0.01 : width / 2 + 0.01;
                            sideWindow.position.z = 0;
                            sideWindow.rotation.y = j === 0 ? -Math.PI / 2 : Math.PI / 2;
                            group.add(sideWindow);
                        }
                    }
                }
            }
            
            // Roof
            const roofGeometry = new THREE.ConeGeometry(Math.max(width, depth) / Math.sqrt(2) + 0.5, height / 2, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                flatShading: true
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = height;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            group.add(roof);
            
            group.position.set(x, 0, z);
            scene.add(group);
            return group;
        }
        
        // Create a tree
        function createTree(x, z) {
            const group = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                flatShading: true
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            group.add(trunk);
            
            // Tree top
            const topGeometry = new THREE.ConeGeometry(2, 4, 8);
            const topMaterial = new THREE.MeshStandardMaterial({
                color: 0x228b22,
                flatShading: true
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 3;
            top.castShadow = true;
            group.add(top);
            
            group.position.set(x, 0, z);
            scene.add(group);
            return group;
        }
        
        // Create bot players
        function createBotPlayers() {
            const botColors = [
                0xff5252, // Red
                0x7b1fa2, // Purple
                0xff9800, // Orange
                0x4caf50, // Green
                0xffeb3b  // Yellow
            ];
            
            const botNames = ['AlphaBot', 'NexusPlayer', 'ShadowRunner', 'QuantumGamer', 'PixelWarrior'];
            
            for (let i = 0; i < 5; i++) {
                const botPlayer = {
                    name: botNames[i],
                    color: new THREE.Color(botColors[i]),
                    position: new THREE.Vector3(
                        Math.random() * 160 - 80,
                        player.height,
                        Math.random() * 160 - 80
                    ),
                    targetPosition: new THREE.Vector3(),
                    health: 100,
                    score: Math.floor(Math.random() * 20),
                    mesh: null,
                    speed: 0.05 + Math.random() * 0.1,
                    lastUpdate: 0,
                    updateInterval: 2000 + Math.random() * 3000
                };
                
                // Create bot mesh
                const bodyGeometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: botColors[i],
                    flatShading: true
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = player.height;
                body.castShadow = true;
                scene.add(body);
                
                botPlayer.mesh = body;
                botPlayer.targetPosition.copy(botPlayer.position);
                botPlayer.targetPosition.x += Math.random() * 40 - 20;
                botPlayer.targetPosition.z += Math.random() * 40 - 20;
                
                botPlayers.push(botPlayer);
            }
        }
        
        // Set up minimap
        function setupMinimap() {
            minimapScene = new THREE.Scene();
            minimapScene.background = new THREE.Color(0x000000);
            
            minimapCamera = new THREE.OrthographicCamera(
                -50, 50, 50, -50, 1, 1000
            );
            minimapCamera.position.set(0, 100, 0);
            minimapCamera.lookAt(0, 0, 0);
            
            minimapRenderer = new THREE.WebGLRenderer({ antialias: true });
            minimapRenderer.setSize(150, 150);
            minimap.appendChild(minimapRenderer.domElement);
            
            // Create minimap ground
            const minimapGround = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshBasicMaterial({ color: 0x1f6032 })
            );
            minimapGround.rotation.x = -Math.PI / 2;
            minimapScene.add(minimapGround);
            
            // Create player marker
            const playerMarker = new THREE.Mesh(
                new THREE.CircleGeometry(2, 16),
                new THREE.MeshBasicMaterial({ color: player.color })
            );
            playerMarker.rotation.x = -Math.PI / 2;
            playerMarker.position.y = 0.1;
            minimapScene.add(playerMarker);
            
            // Create bot markers
            botPlayers.forEach(bot => {
                const botMarker = new THREE.Mesh(
                    new THREE.CircleGeometry(1.5, 16),
                    new THREE.MeshBasicMaterial({ color: bot.color })
                );
                botMarker.rotation.x = -Math.PI / 2;
                botMarker.position.y = 0.1;
                botMarker.position.x = bot.position.x;
                botMarker.position.z = bot.position.z;
                bot.minimapMarker = botMarker;
                minimapScene.add(botMarker);
            });
            
            // Create building markers
            objects.forEach(obj => {
                if (obj.type === "building") {
                    const buildingMarker = new THREE.Mesh(
                        new THREE.BoxGeometry(obj.scale.x, 0.1, obj.scale.z),
                        new THREE.MeshBasicMaterial({ color: 0x555555 })
                    );
                    buildingMarker.position.set(
                        obj.position.x,
                        0.2,
                        obj.position.z
                    );
                    minimapScene.add(buildingMarker);
                }
            });
        }
        
        // Set up player list
        function setupPlayerList() {
            const playerListContent = document.getElementById('playerListContent');
            
            // Add player to list
            const playerDiv = document.createElement('div');
            playerDiv.className = 'player';
            const playerColorDiv = document.createElement('div');
            playerColorDiv.className = 'playerColor';
            playerColorDiv.style.backgroundColor = '#3498db';
            playerDiv.appendChild(playerColorDiv);
            playerDiv.appendChild(document.createTextNode('You (100HP)'));
            playerListContent.appendChild(playerDiv);
            
            // Add bots to list
            botPlayers.forEach(bot => {
                const botDiv = document.createElement('div');
                botDiv.className = 'player';
                const botColorDiv = document.createElement('div');
                botColorDiv.className = 'playerColor';
                botColorDiv.style.backgroundColor = '#' + bot.color.getHexString();
                botDiv.appendChild(botColorDiv);
                botDiv.appendChild(document.createTextNode(`${bot.name} (${bot.health}HP)`));
                bot.listElement = botDiv;
                playerListContent.appendChild(botDiv);
            });
        }
        
        // Show game elements
        function showGameElements() {
            playerStats.style.display = 'block';
            minimap.style.display = 'block';
            playerList.style.display = 'block';
            crosshair.style.display = 'block';
            chatBox.style.display = 'block';
            instructions.style.display = 'block';
        }
        
        // Hide game elements
        function hideGameElements() {
            playerStats.style.display = 'none';
            minimap.style.display = 'none';
            playerList.style.display = 'none';
            crosshair.style.display = 'none';
            chatBox.style.display = 'none';
            instructions.style.display = 'none';
        }
        
        // Toggle menu
        function toggleMenu() {
            menuOpen = !menuOpen;
            
            if (menuOpen) {
                menuElement.style.display = 'block';
                document.exitPointerLock();
                currentState = GameState.PAUSED;
            } else {
                menuElement.style.display = 'none';
                renderer.domElement.requestPointerLock();
                currentState = GameState.PLAYING;
            }
        }
        
        // Update player movement
        function updatePlayer(delta) {
            // Handle jumping
            if (keys.jump && player.canJump && player.onGround) {
                player.velocity.y = player.jumpForce;
                player.onGround = false;
                player.canJump = false;
            }
            
            // Reset jump ability when key is released
            if (!keys.jump) {
                player.canJump = true;
            }
            
            // Apply gravity
            player.velocity.y -= player.gravity;
            
            // Update vertical position
            camera.position.y += player.velocity.y;
            
            // Check for ground collision
            if (camera.position.y <= player.height) {
                camera.position.y = player.height;
                player.velocity.y = 0;
                player.onGround = true;
            }
            
            // Handle movement
            const direction = new THREE.Vector3();
            
            // Forward/backward
            if (keys.forward) {
                direction.z = -1;
            } else if (keys.backward) {
                direction.z = 1;
            }
            
            // Left/right
            if (keys.left) {
                direction.x = -1;
            } else if (keys.right) {
                direction.x = 1;
            }
            
            // Normalize direction vector to maintain consistent speed when moving diagonally
            if (direction.length() > 0) {
                direction.normalize();
            }
            
            // Adjust direction based on camera rotation
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            
            // Move camera
            camera.position.x += direction.x * player.speed;
            camera.position.z += direction.z * player.speed;
            
            // Simple boundary check
            if (Math.abs(camera.position.x) > 100) {
                camera.position.x = Math.sign(camera.position.x) * 100;
            }
            
            if (Math.abs(camera.position.z) > 100) {
                camera.position.z = Math.sign(camera.position.z) * 100;
            }
            
            // Check for collisions with objects
            objects.forEach(obj => {
                if (obj.geometry && obj.position) {
                    const objBBox = new THREE.Box3().setFromObject(obj);
                    const playerBBox = new THREE.Box3().setFromCenterAndSize(
                        camera.position,
                        new THREE.Vector3(1, 1, 1)
                    );
                    
                    if (objBBox.intersectsBox(playerBBox)) {
                        // Simple collision response: push the player away
                        const objCenter = new THREE.Vector3();
                        objBBox.getCenter(objCenter);
                        
                        const direction = new THREE.Vector3()
                            .subVectors(camera.position, objCenter)
                            .normalize();
                        
                        camera.position.x += direction.x * player.speed * 2;
                        camera.position.z += direction.z * player.speed * 2;
                    }
                }
            });
        }
        
        // Update bot players
        function updateBots(delta) {
            const currentTime = Date.now();
            
            botPlayers.forEach(bot => {
                // Update bot position
                const direction = new THREE.Vector3()
                    .subVectors(bot.targetPosition, bot.position)
                    .normalize();
                
                bot.position.x += direction.x * bot.speed;
                bot.position.z += direction.z * bot.speed;
                
                bot.mesh.position.x = bot.position.x;
                bot.mesh.position.z = bot.position.z;
                
                // Update minimap marker
                if (bot.minimapMarker) {
                    bot.minimapMarker.position.x = bot.position.x;
                    bot.minimapMarker.position.z = bot.position.z;
                }
                
                // Check if bot reached target position
                if (bot.position.distanceTo(bot.targetPosition) < 1) {
                    // Choose new target position
                    if (currentTime - bot.lastUpdate > bot.updateInterval) {
                        bot.targetPosition.set(
                            Math.random() * 160 - 80,
                            player.height,
                            Math.random() * 160 - 80
                        );
                        bot.lastUpdate = currentTime;
                        
                        // Randomly send a chat message
                        if (Math.random() < 0.2) {
                            const messages = [
                                "Anyone see any players around?",
                                "This map is huge!",
                                "I'm heading to the center area",
                                "Got some good loot here",
                                "Watch out, snipers on the hill!"
                            ];
                            
                            addChatMessage(bot.name, messages[Math.floor(Math.random() * messages.length)]);
                        }
                    }
                }
                
                // Make bot look at target
                bot.mesh.lookAt(bot.targetPosition);
            });
        }
        
        // Update projectiles
        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                // Move projectile
                projectile.position.add(projectile.velocity);
                
                // Check lifetime
                projectile.lifetime -= delta;
                if (projectile.lifetime <= 0) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check for collisions with bots
                botPlayers.forEach(bot => {
                    if (bot.health > 0 && 
                        projectile.position.distanceTo(bot.position) < 1) {
                        // Hit bot
                        bot.health -= 20;
                        if (bot.listElement) {
                            bot.listElement.childNodes[1].nodeValue = `${bot.name} (${bot.health}HP)`;
                        }
                        
                        if (bot.health <= 0) {
                            // Bot eliminated
                            showNotification(`You eliminated ${bot.name}!`);
                            player.score += 10;
                            updatePlayerStats();
                            
                            // Respawn bot after delay
                            setTimeout(() => {
                                bot.health = 100;
                                bot.position.set(
                                    Math.random() * 160 - 80,
                                    player.height,
                                    Math.random() * 160 - 80
                                );
                                if (bot.listElement) {
                                    bot.listElement.childNodes[1].nodeValue = `${bot.name} (${bot.health}HP)`;
                                }
                            }, 5000);
                        }
                        
                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        break;
                    }
                });
            }
        }
        
        // Shoot function
        function shoot() {
            if (player.ammo[player.weapon] <= 0) {
                reloadWeapon();
                return;
            }
            
            const currentTime = Date.now();
            if (currentTime - player.lastShot < player.shootCooldown) {
                return;
            }
            
            player.lastShot = currentTime;
            player.ammo[player.weapon]--;
            updatePlayerStats();
            
            // Create projectile
            const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            
            // Set projectile position and direction
            projectile.position.set(
                camera.position.x,
                camera.position.y,
                camera.position.z
            );
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            projectile.velocity = direction.multiplyScalar(1);
            projectile.lifetime = 2; // seconds
            
            scene.add(projectile);
            projectiles.push(projectile);
        }
        
        // Reload weapon
        function reloadWeapon() {
            player.ammo[player.weapon] = player.maxAmmo[player.weapon];
            updatePlayerStats();
            showNotification(`Reloaded ${player.weapon}`);
        }
        
        // Change weapon
        function changeWeapon(weaponName) {
            player.weapon = weaponName;
            updatePlayerStats();
            showNotification(`Switched to ${weaponName}`);
            
            // Set shoot cooldown based on weapon
            switch(weaponName) {
                case 'Pistol':
                    player.shootCooldown = 500;
                    break;
                case 'Rifle':
                    player.shootCooldown = 100;
                    break;
                case 'Shotgun':
                    player.shootCooldown = 800;
                    break;
            }
        }
        
        // Toggle chat
        function toggleChat() {
            const input = chatInput.querySelector('input');
            
            if (input.disabled) {
                // Enable chat
                chatInput.style.display = 'block';
                input.disabled = false;
                input.focus();
                
                // Disable controls temporarily
                document.exitPointerLock();
                
                // Listen for Enter key
                const enterHandler = (e) => {
                    if (e.key === 'Enter') {
                        const message = input.value.trim();
                        if (message) {
                            addChatMessage('You', message);
                        }
                        
                        // Reset input
                        input.value = '';
                        input.disabled = true;
                        chatInput.style.display = 'none';
                        
                        // Re-enable controls
                        renderer.domElement.requestPointerLock();
                        
                        // Remove event listener
                        input.removeEventListener('keydown', enterHandler);
                    } else if (e.key === 'Escape') {
                        // Cancel chat
                        input.value = '';
                        input.disabled = true;
                        chatInput.style.display = 'none';
                        
                        // Re-enable controls
                        renderer.domElement.requestPointerLock();
                        
                        // Remove event listener
                        input.removeEventListener('keydown', enterHandler);
                    }
                };
                
                input.addEventListener('keydown', enterHandler);
            }
        }
        
        // Add chat message
        function addChatMessage(sender, message) {
            const chatBox = document.getElementById('chatBox');
            const messageElement = document.createElement('div');
            messageElement.className = 'chatMessage';
            messageElement.textContent = `${sender}: ${message}`;
            chatBox.appendChild(messageElement);
            
            // Scroll to bottom
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Remove old messages if too many
            while (chatBox.childNodes.length > 10) {
                chatBox.removeChild(chatBox.firstChild);
            }
        }
        
        // Show notification
        function showNotification(message) {
            // Check if notification already exists
            let notification = document.querySelector('.notification');
            
            if (!notification) {
                notification = document.createElement('div');
                notification.className = 'notification';
                document.body.appendChild(notification);
            }
            
            notification.textContent = message;
            notification.style.opacity = 1;
            
            // Hide after delay
            setTimeout(() => {
                notification.style.opacity = 0;
            }, 2000);
        }
        
        // Update player stats UI
        function updatePlayerStats() {
            document.getElementById('healthValue').textContent = player.health;
            document.getElementById('healthFill').style.width = `${player.health}%`;
            document.getElementById('scoreValue').textContent = player.score;
            document.getElementById('weaponValue').textContent = `${player.weapon} (${player.ammo[player.weapon]}/${player.maxAmmo[player.weapon]})`;
        }
        
        // Update graphics quality
        function updateGraphicsQuality() {
            switch(config.graphics) {
                case 'low':
                    renderer.setPixelRatio(window.devicePixelRatio * 0.5);
                    renderer.shadowMap.enabled = false;
                    break;
                case 'medium':
                    renderer.setPixelRatio(window.devicePixelRatio * 0.75);
                    renderer.shadowMap.enabled = true;
                    break;
                case 'high':
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.shadowMap.enabled = true;
                    break;
            }
        }
        
        // Respawn player
        function respawnPlayer() {
            player.health = 100;
            camera.position.set(0, player.height, 0);
            player.velocity.set(0, 0, 0);
            updatePlayerStats();
            
            toggleMenu();
            showNotification('Respawned!');
        }
        
        // Restart game
        function restartGame() {
            player.health = 100;
            player.score = 0;
            camera.position.set(0, player.height, 0);
            player.velocity.set(0, 0, 0);
            updatePlayerStats();
            
            toggleMenu();
            showNotification('Game restarted!');
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (currentState === GameState.PLAYING && !menuOpen) {
                // Update player movement
                updatePlayer(delta);
                
                // Update bot players
                updateBots(delta);
                
                // Update projectiles
                updateProjectiles(delta);
                
                // Update minimap player marker position
                if (minimapScene) {
                    const playerMarker = minimapScene.children.find(child => 
                        child.geometry && child.geometry.type === 'CircleGeometry' && 
                        child.material.color.equals(player.color));
                    
                    if (playerMarker) {
                        playerMarker.position.x = camera.position.x;
                        playerMarker.position.z = camera.position.z;
                    }
                }
            }
            
            // Render main scene
            renderer.render(scene, camera);
            
            // Render minimap if available
            if (minimapRenderer && minimapScene && minimapCamera) {
                minimapRenderer.render(minimapScene, minimapCamera);
            }
        }
        
        // Initialize the game
        init();
    </script>
</body>
</html>
