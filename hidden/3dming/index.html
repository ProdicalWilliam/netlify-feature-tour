<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Web Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="instructions">
        WASD or Arrow Keys to move<br>
        Mouse to look around<br>
        Space to jump<br>
        Click to lock pointer
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x33aa33,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        scene.add(ground);

        // Add some boxes
        function createBox(x, y, z, color = 0x3333aa) {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshStandardMaterial({ color });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(x, y, z);
            scene.add(box);
            return box;
        }

        // Add some random boxes
        const boxes = [];
        for (let i = 0; i < 20; i++) {
            const x = Math.random() * 80 - 40;
            const z = Math.random() * 80 - 40;
            const color = new THREE.Color(Math.random() * 0xffffff);
            boxes.push(createBox(x, 0, z, color));
        }

        // Add some tall blocks for obstacles
        for (let i = 0; i < 10; i++) {
            const x = Math.random() * 60 - 30;
            const z = Math.random() * 60 - 30;
            const height = Math.random() * 4 + 2;
            const geometry = new THREE.BoxGeometry(3, height, 3);
            const material = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color(Math.random() * 0xffffff)
            });
            const tower = new THREE.Mesh(geometry, material);
            tower.position.set(x, height/2 - 1, z);
            scene.add(tower);
        }

        // Player controls variables
        const player = {
            height: 1.7,
            speed: 0.1,
            turnSpeed: 0.03,
            jumpForce: 0.15,
            gravity: 0.005,
            velocity: new THREE.Vector3(0, 0, 0),
            onGround: true,
            canJump: true
        };

        camera.position.y = player.height;

        // Controls state
        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false
        };

        // Pointer lock API controls
        const pointerLock = {
            isLocked: false
        };

        // Event listeners for keyboard
        document.addEventListener('keydown', (event) => {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.forward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.backward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = true;
                    break;
                case 'Space':
                    keys.jump = true;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.forward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.backward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'Space':
                    keys.jump = false;
                    break;
            }
        });

        // Mouse controls
        document.addEventListener('click', () => {
            if (!pointerLock.isLocked) {
                renderer.domElement.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            pointerLock.isLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (event) => {
            if (pointerLock.isLocked) {
                camera.rotation.y -= event.movementX * 0.002;
                const verticalLook = camera.rotation.x + event.movementY * 0.002;
                // Limit looking up and down
                camera.rotation.x = Math.max(Math.min(verticalLook, Math.PI / 2), -Math.PI / 2);
            }
        });

        // Player movement functions
        function updatePlayer() {
            // Handle jumping
            if (keys.jump && player.canJump && player.onGround) {
                player.velocity.y = player.jumpForce;
                player.onGround = false;
                player.canJump = false;
            }
            
            // Reset jump ability when key is released
            if (!keys.jump) {
                player.canJump = true;
            }
            
            // Apply gravity
            player.velocity.y -= player.gravity;
            
            // Update vertical position
            camera.position.y += player.velocity.y;
            
            // Check for ground collision
            if (camera.position.y <= player.height) {
                camera.position.y = player.height;
                player.velocity.y = 0;
                player.onGround = true;
            }

            // Handle movement
            const direction = new THREE.Vector3();
            
            // Forward/backward
            if (keys.forward) {
                direction.z = -1;
            } else if (keys.backward) {
                direction.z = 1;
            }
            
            // Left/right
            if (keys.left) {
                direction.x = -1;
            } else if (keys.right) {
                direction.x = 1;
            }

            // Normalize direction vector to maintain consistent speed when moving diagonally
            if (direction.length() > 0) {
                direction.normalize();
            }
            
            // Adjust direction based on camera rotation
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            
            // Move camera
            camera.position.x += direction.x * player.speed;
            camera.position.z += direction.z * player.speed;
            
            // Simple boundary check
            if (Math.abs(camera.position.x) > 50) {
                camera.position.x = Math.sign(camera.position.x) * 50;
            }
            
            if (Math.abs(camera.position.z) > 50) {
                camera.position.z = Math.sign(camera.position.z) * 50;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update player movement
            updatePlayer();
            
            // Animate boxes
            boxes.forEach((box, index) => {
                box.rotation.x += 0.01;
                box.rotation.y += 0.01;
                box.position.y = Math.sin(Date.now() * 0.001 + index) + 1;
            });
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation loop
        animate();
    </script>
</body>
</html>
